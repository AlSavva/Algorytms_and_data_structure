# 1. Отсортируйте по убыванию методом пузырька одномерный целочисленный массив,
# заданный случайными числами на промежутке [-100; 100). Выведите на экран
# исходный и отсортированный массивы.
# Примечания:
# a. алгоритм сортировки должен быть в виде функции, которая принимает на вход
# массив данных,
# b. постарайтесь сделать алгоритм умнее, но помните, что у вас должна остаться
# сортировка пузырьком. Улучшенные версии сортировки, например, расчёской,
# шейкерная и другие в зачёт не идут.

import random


def full_randarray(x, y, size):
    """
    Возвращает массив из size элементов от x до y(исключительно) в произвольном
    порядке
    """
    array = [random.randint(x, y - 1) for _ in range(size)]
    random.shuffle(array)
    return array

def bubsort_rev(array):
    """
    реализация сортировки пузырьком в обратном порядке
    :param array:
    :return: отсортированый массив от большего к меньшему
    """
    # для сравнения результатов работы функций bubsort_rev и bubsort_revmod
    # используем метод deepcopy, чтобы не было изменнений в исходном списке
    from copy import deepcopy
    array = deepcopy(array)
    n = 1
    # Для наглядности сравнения вводим переременную count, для подсчета
    # количества замен значений при работе функции
    count = 0
    # Для наглядности сравнениявводим переременную chek, для подсчета
    # количества проходов по списку при работе функции.
    chek = 0
    while n < len(array):
        for i in range(len(array) - n):
            if array[i] < array[i + 1]:
                array[i], array[i + 1] = array[i + 1], array[i]
                count += 1
            chek +=1
        n += 1
    print(f'Количество сравнений= {chek}, количество замен= {count}')
    return array


def bubsort_revmod(array):
    """
        модифицированная реализация сортировки пузырьком в обратном порядке
        :param array:
        :return: отсортированый массив от большего к меньшему
        """
    from copy import deepcopy
    array = deepcopy(array)
    n = 1
    count = 0
    chek = 0
    while n < len(array):
        # Вводим переменную maxcount, которая будет отслеживать, производились
        # ли замены при проходе по списку. Если нет - значит оставшаяся часть
        # списка уже отсортирована.
        maxcount = 0
        for i in range(len(array) - n):
            if array[i] < array[i + 1]:
                array[i], array[i + 1] = array[i + 1], array[i]
                count += 1
                maxcount = count
            chek += 1
        if maxcount == 0:
            break
        else:
            n += 1
    print(f'Количество сравнений= {chek}, количество замен= {count}')
    return array



a = full_randarray(-100, 100, 10)
print(f'Исходный список: {a}')
print(f'Результат: {bubsort_rev(a)}')
print(f'Исходный список: {a}')
print(f'Результат: {bubsort_revmod(a)}')

# из работы алгоритмов видно незначительное ускорение в работе модифицированой
# функцииб за счёт меньшего количества проходов по списку

